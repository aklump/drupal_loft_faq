<?php
/**
 * @file
 * Base module file for loft_faq
 *
 * @defgroup loft_faq FAQ
 * @{
 */

// autocomplete path for this module
define('LOFT_FAQ_AUTOCOMPLETE', 'loft-faq/autocomplete');

/**
 * @var LOFT_FAQ_GROUP_DEFAULT
 * The default group
 */
define('LOFT_FAQ_GROUP_DEFAULT', 'General');

/**
 * @var LOFT_FAQ_PATH_ADMIN_SETTINGS
 *
 * Path to admin settings
 */
define('LOFT_FAQ_PATH_ADMIN_SETTINGS', 'admin/settings/loft-faq');

/**
 * Get functional nodes; these should not be deleted!
 *
 * If nid is provided return bool if this is a core node
 *
 * @return array or bool
 */
function _loft_faq_core_nodes($nid = NULL) {
  $core_nids = array();
  if (variable_get('loft_faq_faq_page_nid', NULL)) {
    $core_nids[] = variable_get('loft_faq_faq_page_nid', NULL);
  }
  if ($nid) {
    return in_array($nid, $core_nids);
  }
  return $core_nids;
}

/**
 * Implementation of hook_form_alter
 */
function loft_faq_form_alter(&$form, $form_state, $form_id) {
  if ($form['#id'] == 'node-form' && _loft_faq_core_nodes($form['nid']['#value'])) {
    unset($form['buttons']['delete']);

    //create an auto menu link for the faq node
    if ($form['nid']['#value'] == variable_get('loft_faq_faq_page_nid', NULL) &&
        empty($form['menu']['link_title']['#default_value'])) {
      $form['menu']['#collapsed'] = 0;
      $form['menu']['link_title']['#default_value'] = t('FAQ');
    }
  }
}

/**
 * Implementation of hook_help()
 *
 * http://api.drupal.org/api/function/hook_help
 *
 * @param string $path
 *   The router menu path, as defined in hook_menu(), for the help that is
 *   being requested; e.g., 'admin/node' or 'user/edit'. If the router path
 *   includes a % wildcard, then this will appear in $path; for example, node
 *   pages would have $path equal to 'node/%' or 'node/%/view'. Your hook
 *   implementation may also be called with special descriptors after a "#" sign.
 * @param array $arg
 *   An array that corresponds to the return value of the arg() function, for
 *   modules that want to provide help that is specific to certain values of
 *   wildcards in $path. For example, you could provide help for the path
 *   'user/1' by looking for the path 'user/%' and $arg[1] == '1'. This array
 *   should always be used rather than directly invoking arg(), because your
 *   hook implementation may be called for other purposes besides building the
 *   current page's help. Note that depending on which module is invoking
 *   hook_help, $arg may contain only empty strings. Regardless, $arg[0] to
 *   $arg[11] will always be set.
 */
function loft_faq_help($path, $arg) {
  switch ($path) {
    case 'admin/help#loft_faq':

      // Return a line-break version of the module README
      return filter_filter('process', 1, NULL, file_get_contents(dirname(__FILE__) ."/README.txt"));

    case 'node/%/edit':
      if ($arg[1] == variable_get('loft_faq_faq_page_nid', NULL)) {
        $help = '<p>' . t('The <strong>Frequently Asked Questions</strong> are appended to the content of this node. <a href="@url">Adjust settings.</a>', array('@url' => url(LOFT_FAQ_PATH_ADMIN_SETTINGS))) . '</p>';
      }
      return $help;

  }
}

/**
 * Implementation of hook_init()
 */
function loft_faq_init() {
  if ($_GET['q'] != LOFT_FAQ_PATH_ADMIN_SETTINGS &&
      !($nid = variable_get('loft_faq_faq_page_nid', NULL))) {
    drupal_set_message(t('Please define which node to use as your FAQ page by visiting <a href="@url">@url</a>, or disable the Frequently Asked Questions module.', array('@url' => url(LOFT_FAQ_PATH_ADMIN_SETTINGS))), 'warning', FALSE);
  }
}

/**
 * Implements hook_perm().
 */
function loft_faq_perm() {
  return array(
    'administer loft_faq',
  );
}

/**
 * Implementation of hook_menu()
 */
function loft_faq_menu() {
  $items = array();

  $items[LOFT_FAQ_PATH_ADMIN_SETTINGS] = array(
    'title' => 'FAQ settings',
    'description' => 'Configure how FAQ behaves.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('loft_faq_admin_settings'),
    'file' => 'loft_faq.admin.inc',
    'access arguments' => array('administer loft_faq'),
    'type' => MENU_NORMAL_ITEM,
  );

  $items[LOFT_FAQ_AUTOCOMPLETE] = array(
    'page callback' => 'loft_faq_autocomplete',
    'access arguments' => array('administer content'),
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Implementation of hook_preprocess_node()
 */
function loft_faq_preprocess_node(&$vars) {
  if ($vars['node']->nid == variable_get('loft_faq_faq_page_nid', NULL)) {
    $output = '';
    $toc = array();
    foreach (loft_faq_get_faq_categories() as $key => $category) {
      $category = empty($category) ? variable_get('loft_faq_group_default', LOFT_FAQ_GROUP_DEFAULT) : $category;
      if ($nodes = loft_faq_get_faq_by_category($key)) {
        $anchor = loft_faq_css_safe($category);
        $toc[$anchor] = $category;
        $output .= theme("loft_faq_list", $category, $anchor, $nodes) . "\n";
      }
    }
    drupal_add_js(drupal_get_path('module', 'loft_faq') . '/loft_faq.js', 'file');
    $vars['content'] .= theme("loft_faq_toc", $toc);
    $vars['content'] .= $output;
  }
}

/**
 * Implementation of hook_link
 *
 * The returned array should be a keyed array of link entries. Each link can be in one of two formats.
 *
 * @param string $type
 *   An identifier declaring what kind of link is being requested. Possible values:
 *    comment: Links to be placed below a comment being viewed.
 *    node: Links to be placed below a node being viewed.
 * @param object $object
 *   A node object or a comment object according to the $type.
 * @param bool $teaser
 *   In case of node link: a 0/1 flag depending on whether the node is displayed with its teaser or its full form.
 *
 * @return array
 *   The returned array should be a keyed array of link entries. Each link can be in one of two formats.
 *
 *   The first format will use the l() function to render the link:
 *   - attributes: Optional. See l() for usage.
 *   - fragment: Optional. See l() for usage.
 *   - href: Required. The URL of the link.
 *   - html: Optional. See l() for usage.
 *   - query: Optional. See l() for usage.
 *   - title: Required. The name of the link.
 *
 *   The second format can be used for non-links. Leaving out the href index will select this format:
 *   - title: Required. The text or HTML code to display.
 *   - attributes: Optional. An associative array of HTML attributes to apply to the span tag.
 *   - html: Optional. If not set to true, check_plain() will be run on the title before it is displayed.
 */
function loft_faq_link($type, $object, $teaser = FALSE) {
  $links = array();
  if ($type == 'node' && $object->nid == variable_get('loft_faq_faq_page_nid', NULL) && !$teaser) {
    if (user_access('create lfaq')) {
      $links['loft_faq_add_faq'] = array(
        'title' => 'Add Another FAQ',
        'href' => 'node/add/lfaq',
        'query' => drupal_get_destination(),
        'attributes' => array('class' => 'loft-faq-add-link'),
      );
    }
  }
  return $links;
}

/**
 * Implementation of hook_theme
 */
function loft_faq_theme($existing, $type, $theme, $path) {
  return array(
    'loft_faq_toc' => array(
      'arguments' => array('items' => array()),
      'template' => 'loft_faq-toc',
    ),
    'loft_faq_list' => array(
      'arguments' => array('category' => NULL, 'anchor' => NULL, 'nodes' => array()),
      'template' => 'loft_faq-list',
    ),
  );
}

/**
 * Get a list of faq nodes by category
 *
 * They are ordered by weight field
 *
 * @param string $category
 *
 * @return array
 * - an array of nodes keyed by nid
 */
function loft_faq_get_faq_by_category($category, $reset = FALSE) {
  static $faq;
  if (empty($faq[$category]) || $reset) {

    //the default category will actually be looking for a blank spot @see loft_faq_nodeapi
    if (($default = variable_get('loft_faq_group_default', LOFT_FAQ_GROUP_DEFAULT) && $category == 'default')) {
      $category = '';
    }
    $result = db_query("SELECT n.nid FROM {node} n JOIN {lfaq} f USING (vid) WHERE status=1 AND f.`group` = '%s' ORDER BY f.weight ASC", $category);
    while ($data = db_fetch_object($result)) {
      if (($node = node_load($data->nid)) && node_access('view', $node)) {
        $faq[$category][$node->nid] = $node;
      }
    }
  }
  return $faq[$category];
}

/**
 * Get an array of FAQ categories
 *
 * They are in alphabetical order by Category
 *
 * @param bool $test_perms
 *
 * @return array
 *   keys and values are the stored category; DO NOT CHANGE THE KEY TO NUMERIC
 */
function loft_faq_get_faq_categories($reset = FALSE) {
  static $categories;
  if (empty($categories) || $reset) {
    $default = variable_get('loft_faq_group_default', LOFT_FAQ_GROUP_DEFAULT);
    $categories = drupal_map_assoc(array($default));
    $result = db_query("SELECT DISTINCT(`group`) FROM {lfaq} g JOIN {node} n USING (vid) WHERE n.status = 1 ORDER by `group` ASC");
    while ($data = db_fetch_object($result)) {
      $categories[$data->group] = $data->group;
    }
  }
  return $categories;
}

/**
 * Make a css safe class or id
 *
 * @param string or array $input
 *   The string will be made css safe; array values will be made css safe
 * @param bool $flatten
 *   Optional.  Set to TRUE to flatten arrays into space separated strings
 *
 * @return string or array
 */
function loft_faq_css_safe($input, $flatten = FALSE) {
  if (is_array($input)) {
    $function = __FUNCTION__;
    foreach ($input as $key => $value) {
      $input[$key] = $function($value);
    }
    return $flatten ? trim(implode(' ', $input)) : $input;
  }
  elseif (is_string($input)) {
    return trim(strtolower(preg_replace('/[\W_]+/', '-', $input)), '-');
  }
  return $input;
}

/**
 * Implementation of hook_form_alter
 */
function loft_faq_form_lfaq_node_form_alter(&$form, $form_state) {
  $form['group']['#autocomplete_path'] = LOFT_FAQ_AUTOCOMPLETE . '/lfaq/group';
  $form['group']['#description'] = t('Enter a grouping field for this QA. If unsure enter %default.', array(
    '%default' => variable_get('loft_faq_group_default', LOFT_FAQ_GROUP_DEFAULT),
  ));
  $form['group']['#default_value'] = empty($form['group']['#default_value']) ? variable_get('loft_faq_group_default', LOFT_FAQ_GROUP_DEFAULT) : $form['group']['#default_value'];
  $form['#validate'][] = 'loft_faq_form_lfaq_node_form_validate';
}

/**
 * Implementation of hook_nodeapi()
 * http://api.drupal.org/api/function/hook_nodeapi
 * - "alter": the $node->content array has been rendered, so the node body or
 *        teaser is filtered and now contains HTML. This op should only be used when
 *        text substitution, filtering, or other raw text operations are necessary.
 * - "delete": The node is being deleted.
 * - "delete revision": The revision of the node is deleted. You can delete data
 *        associated with that revision.
 * - "insert": The node is being created (inserted in the database).
 * - "load": The node is about to be loaded from the database. This hook can be
 *       used to load additional data at this time.
 * - "prepare": The node is about to be shown on the add/edit form.
 * - "prepare translation": The node is being cloned for translation. Load
 *       additional data or copy values from $node->translation_source.
 * - "print": Prepare a node view for printing. Used for printer-friendly view
 *       in book_module
 * - "rss item": An RSS feed is generated. The module can return properties to
 *       be added to the RSS item generated for this node. See comment_nodeapi() and
 *       upload_nodeapi() for examples. The $node passed can also be modified to add
 *       or remove contents to the feed item.
 * - "search result": The node is displayed as a search result. If you want to
 *        display extra information with the result, return it.
 * - "presave": The node passed validation and is about to be saved. Modules may
 *        use this to make changes to the node before it is saved to the database.
 * - "update": The node is being updated.
 * - "update index": The node is being indexed. If you want additional
 *        information to be indexed which is not already visible through nodeapi
 *        "view", then you should return it here.
 * - "validate": The user has just finished editing the node and is trying to
 *        preview or submit it. This hook can be used to check the node data. Errors
 *        should be set with form_set_error().
 * - "view": The node content is being assembled before rendering. The module
 *        may add elements $node->content prior to rendering. This hook will be called
 *        after hook_view(). The format of $node->content is the same as used by Forms
 *        API.
 */
function loft_faq_nodeapi(&$node, $op, $a3 = NULL, $a4 = NULL) {
  if ($node->type == 'lfaq') {
    if ($op == 'presave') {
      //for flexibility sake (changing the default group on the fly from admin and
      //quick updates) we don't want to actually record teh default group to the
      //db, we'll leave it blank and insert the default on load, etc.
      if (($default = variable_get('loft_faq_group_default', LOFT_FAQ_GROUP_DEFAULT)) && $default == $node->group) {
        $node->group = '';
      }
    }
    elseif ($op == 'load' && ($default = variable_get('loft_faq_group_default', LOFT_FAQ_GROUP_DEFAULT)) && empty($node->group)) {

      //fill in the blanks with default on load
      $node->group = $default;
    }
  }
}

/**
 * Return the list of autocomplete suggestions
 *
 * @param string $node_type
 * @param string $field
 * @param string $string
 *   The user input
 *
 * @return json
 */
function loft_faq_autocomplete($node_type, $field, $string = '') {
  $matches = array();
  if ($string) {
    $suggestions = array();
    switch ($node_type) {
      case 'lfaq':
        switch ($field) {

          //find all the matching fieldgroups
          case 'group':
            foreach (loft_faq_get_faq_categories() as $category) {
              //the string is anywhere in the choice
              if (stristr($category, $string) !== FALSE) {
                $suggestions[$category] = $category;
              }
            }
            break;
        }
        break;
    }
  }
  drupal_json($suggestions);
  exit();
}
